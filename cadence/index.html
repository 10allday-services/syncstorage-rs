<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `cadence` crate."><meta name="keywords" content="rust, rustlang, rust-lang, cadence"><title>cadence - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../cadence/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate cadence</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all cadence's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'cadence', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/cadence/lib.rs.html#11-381' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>cadence</a></span></h1><div class='docblock'><p>An extensible Statsd client for Rust!</p>
<p><a href="https://github.com/etsy/statsd">Statsd</a> is a network server that listens for
metrics (things like counters and timers) sent over UDP and sends aggregates of
these metrics to a backend service of some kind (often
<a href="http://graphite.readthedocs.org/">Graphite</a>).</p>
<p>Cadence is a client written in Rust for interacting with a Statsd server. You
might want to emit metrics (using Cadence, sending them to a Statsd server) in
your Rust server application.</p>
<p>For example, if you are running a Rust web service you might want to record:</p>
<ul>
<li>Number of successful requests</li>
<li>Number of error requests</li>
<li>Time taken for each request</li>
</ul>
<p>Cadence is a flexible and easy way to do this!</p>
<h2 id="features" class="section-header"><a href="#features">Features</a></h2>
<ul>
<li>Support for emitting counters, timers, histograms, gauges, meters, and sets to
Statsd over UDP.</li>
<li>Support for alternate backends via the <code>MetricSink</code> trait.</li>
<li>Support for <a href="https://docs.datadoghq.com/developers/dogstatsd/">Datadog</a> style metric
tags.</li>
<li>A simple yet flexible API for sending metrics.</li>
</ul>
<h2 id="install" class="section-header"><a href="#install">Install</a></h2>
<p>To make use of Cadence in your project, add it as a dependency in your
<code>Cargo.toml</code> file.</p>
<pre><code class="language-toml">[dependencies]
cadence = &quot;x.y.z&quot;
</code></pre>
<p>Then, link to it in your library or application.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// bin.rs or lib.rs</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">cadence</span>;

<span class="comment">// rest of your library or application</span></pre></div>
<h2 id="usage" class="section-header"><a href="#usage">Usage</a></h2>
<p>Some examples of how to use Cadence are shown below. The examples start
simple and work up to how you should be using Cadence in a production
application.</p>
<h3 id="simple-use" class="section-header"><a href="#simple-use">Simple Use</a></h3>
<p>Simple usage of Cadence is shown below. In this example, we just import
the client, create an instance that will write to some imaginary metrics
server, and send a few metrics.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Import the client.</span>
<span class="kw">use</span> <span class="ident">cadence</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">UdpMetricSink</span>, <span class="ident">DEFAULT_PORT</span>};

<span class="comment">// Create client that will write to the given host over UDP.</span>
<span class="comment">//</span>
<span class="comment">// Note that you&#39;ll probably want to actually handle any errors creating</span>
<span class="comment">// the client when you use it for real in your application. We&#39;re just</span>
<span class="comment">// using .unwrap() here since this is an example!</span>
<span class="kw">let</span> <span class="ident">host</span> <span class="op">=</span> (<span class="string">&quot;metrics.example.com&quot;</span>, <span class="ident">DEFAULT_PORT</span>);
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient</span>::<span class="ident">from_udp_host</span>(<span class="string">&quot;my.metrics&quot;</span>, <span class="ident">host</span>).<span class="ident">unwrap</span>();

<span class="comment">// Emit metrics!</span>
<span class="ident">client</span>.<span class="ident">incr</span>(<span class="string">&quot;some.counter&quot;</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;some.methodCall&quot;</span>, <span class="number">42</span>);
<span class="ident">client</span>.<span class="ident">gauge</span>(<span class="string">&quot;some.thing&quot;</span>, <span class="number">7</span>);
<span class="ident">client</span>.<span class="ident">meter</span>(<span class="string">&quot;some.value&quot;</span>, <span class="number">5</span>);</pre></div>
<h3 id="buffered-udp-sink" class="section-header"><a href="#buffered-udp-sink">Buffered UDP Sink</a></h3>
<p>While sending a metric over UDP is very fast, the overhead of frequent
network calls can start to add up. This is especially true if you are
writing a high performance application that emits a lot of metrics.</p>
<p>To make sure that metrics aren't interfering with the performance of
your application, you may want to use a <code>MetricSink</code> implementation that
buffers multiple metrics before sending them in a single network
operation. For this, there's <code>BufferedUdpMetricSink</code>. An example of
using this sink is given below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">net</span>::<span class="ident">UdpSocket</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">BufferedUdpMetricSink</span>, <span class="ident">DEFAULT_PORT</span>};

<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UdpSocket</span>::<span class="ident">bind</span>(<span class="string">&quot;0.0.0.0:0&quot;</span>).<span class="ident">unwrap</span>();
<span class="ident">socket</span>.<span class="ident">set_nonblocking</span>(<span class="bool-val">true</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">host</span> <span class="op">=</span> (<span class="string">&quot;metrics.example.com&quot;</span>, <span class="ident">DEFAULT_PORT</span>);
<span class="kw">let</span> <span class="ident">sink</span> <span class="op">=</span> <span class="ident">BufferedUdpMetricSink</span>::<span class="ident">from</span>(<span class="ident">host</span>, <span class="ident">socket</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient</span>::<span class="ident">from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">sink</span>);

<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;my.counter.thing&quot;</span>, <span class="number">29</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;my.service.call&quot;</span>, <span class="number">214</span>);
<span class="ident">client</span>.<span class="ident">incr</span>(<span class="string">&quot;some.event&quot;</span>);</pre></div>
<p>As you can see, using this buffered UDP sink is no more complicated
than using the regular, non-buffered, UDP sink.</p>
<p>The only downside to this sink is that metrics aren't written to the
Statsd server until the buffer is full. If you have a busy application
that is constantly emitting metrics, this shouldn't be a problem.
However, if your application only occasionally emits metrics, this sink
might result in the metrics being delayed for a little while until the
buffer fills.</p>
<h3 id="queuing-asynchronous-metric-sink" class="section-header"><a href="#queuing-asynchronous-metric-sink">Queuing Asynchronous Metric Sink</a></h3>
<p>To make sure emitting metrics doesn't interfere with the performance
of your application (even though emitting metrics is generally quite
fast), it's probably a good idea to make sure metrics are emitted in
in a different thread than your application thread.</p>
<p>To allow you do this, there is <code>QueuingMetricSink</code>. This sink allows
you to wrap any other metric sink and send metrics to it via a queue,
as it emits metrics in another thread, asynchronously from the flow of
your application.</p>
<p>The requirements for the wrapped metric sink are that it is thread
safe, meaning that it implements the <code>Send</code> and <code>Sync</code> traits. If
you're using the <code>QueuingMetricSink</code> with another sink from Cadence,
you don't need to worry: they are all thread safe.</p>
<p>An example of using the <code>QueuingMetricSink</code> to wrap a buffered UDP
metric sink is given below. This is the preferred way to use Cadence
in production.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">net</span>::<span class="ident">UdpSocket</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">QueuingMetricSink</span>, <span class="ident">BufferedUdpMetricSink</span>,
              <span class="ident">DEFAULT_PORT</span>};

<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UdpSocket</span>::<span class="ident">bind</span>(<span class="string">&quot;0.0.0.0:0&quot;</span>).<span class="ident">unwrap</span>();
<span class="ident">socket</span>.<span class="ident">set_nonblocking</span>(<span class="bool-val">true</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">host</span> <span class="op">=</span> (<span class="string">&quot;metrics.example.com&quot;</span>, <span class="ident">DEFAULT_PORT</span>);
<span class="kw">let</span> <span class="ident">udp_sink</span> <span class="op">=</span> <span class="ident">BufferedUdpMetricSink</span>::<span class="ident">from</span>(<span class="ident">host</span>, <span class="ident">socket</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">queuing_sink</span> <span class="op">=</span> <span class="ident">QueuingMetricSink</span>::<span class="ident">from</span>(<span class="ident">udp_sink</span>);
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient</span>::<span class="ident">from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">queuing_sink</span>);

<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;my.counter.thing&quot;</span>, <span class="number">29</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;my.service.call&quot;</span>, <span class="number">214</span>);
<span class="ident">client</span>.<span class="ident">incr</span>(<span class="string">&quot;some.event&quot;</span>);</pre></div>
<h3 id="use-with-tags" class="section-header"><a href="#use-with-tags">Use With Tags</a></h3>
<p>Adding tags to metrics is accomplished via the use of each of the <code>_with_tags</code>
methods that are part of the Cadence <code>StatsdClient</code> struct. An example of using
these methods is given below. Note that tags are an extension to the Statsd
protocol and so may not be supported by all servers.</p>
<p>See the <a href="https://docs.datadoghq.com/developers/dogstatsd/">Datadog docs</a> for
more information.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">cadence</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">Metric</span>, <span class="ident">StatsdClient</span>, <span class="ident">NopMetricSink</span>};

<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient</span>::<span class="ident">from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">NopMetricSink</span>);

<span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">client</span>.<span class="ident">count_with_tags</span>(<span class="string">&quot;my.counter&quot;</span>, <span class="number">29</span>)
    .<span class="ident">with_tag</span>(<span class="string">&quot;host&quot;</span>, <span class="string">&quot;web03.example.com&quot;</span>)
    .<span class="ident">with_tag_value</span>(<span class="string">&quot;beta-test&quot;</span>)
    .<span class="ident">try_send</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="macro">concat</span><span class="macro">!</span>(
        <span class="string">&quot;my.prefix.my.counter:29|c|#&quot;</span>,
        <span class="string">&quot;host:web03.example.com,&quot;</span>,
        <span class="string">&quot;beta-test&quot;</span>
    ),
    <span class="ident">res</span>.<span class="ident">unwrap</span>().<span class="ident">as_metric_str</span>()
);</pre></div>
<h3 id="counted-timed-gauged-metered-histogrammed-setted-and-metricclient-traits" class="section-header"><a href="#counted-timed-gauged-metered-histogrammed-setted-and-metricclient-traits"><code>Counted</code>, <code>Timed</code>, <code>Gauged</code>, <code>Metered</code>, <code>Histogrammed</code>, <code>Setted</code>, and <code>MetricClient</code> Traits</a></h3>
<p>Each of the methods that the Cadence <code>StatsdClient</code> struct uses to send
metrics are implemented as a trait. There is also a trait that combines
all of these other traits. If we want, we can just use one of the trait
types to refer to the client instance. This might be useful to you if
you'd like to swap out the actual Cadence client with a dummy version
when you are unit testing your code or want to abstract away all the
implementation details of the client being used behind a trait and
pointer.</p>
<p>Each of these traits are exported in the prelude module. They are also
available in the main module but aren't typically used like that.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">cadence</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">UdpMetricSink</span>, <span class="ident">DEFAULT_PORT</span>};


<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">User</span> {
    <span class="ident">id</span>: <span class="ident">u64</span>,
    <span class="ident">username</span>: <span class="ident">String</span>,
    <span class="ident">email</span>: <span class="ident">String</span>
}


<span class="comment">// Here&#39;s a simple DAO (Data Access Object) that doesn&#39;t do anything but</span>
<span class="comment">// uses a metric client to keep track of the number of times the</span>
<span class="comment">// &#39;getUserById&#39; method gets called.</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">MyUserDao</span> {
    <span class="ident">metrics</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">MetricClient</span><span class="op">&gt;</span>
}


<span class="kw">impl</span> <span class="ident">MyUserDao</span> {
    <span class="comment">// Create a new instance that will use the StatsdClient</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetricClient</span> <span class="op">+</span> <span class="lifetime">&#39;static</span><span class="op">&gt;</span>(<span class="ident">metrics</span>: <span class="ident">T</span>) <span class="op">-&gt;</span> <span class="ident">MyUserDao</span> {
        <span class="ident">MyUserDao</span> { <span class="ident">metrics</span>: <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">metrics</span>) }
    }

    <span class="doccomment">/// Get a new user by their ID</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_user_by_id</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">id</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">User</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">metrics</span>.<span class="ident">incr</span>(<span class="string">&quot;getUserById&quot;</span>);
        <span class="prelude-val">None</span>
    }
}


<span class="comment">// Create a new Statsd client that writes to &quot;metrics.example.com&quot;</span>
<span class="kw">let</span> <span class="ident">host</span> <span class="op">=</span> (<span class="string">&quot;metrics.example.com&quot;</span>, <span class="ident">DEFAULT_PORT</span>);
<span class="kw">let</span> <span class="ident">metrics</span> <span class="op">=</span> <span class="ident">StatsdClient</span>::<span class="ident">from_udp_host</span>(<span class="string">&quot;counter.example&quot;</span>, <span class="ident">host</span>).<span class="ident">unwrap</span>();

<span class="comment">// Create a new instance of the DAO that will use the client</span>
<span class="kw">let</span> <span class="ident">dao</span> <span class="op">=</span> <span class="ident">MyUserDao</span>::<span class="ident">new</span>(<span class="ident">metrics</span>);

<span class="comment">// Try to lookup a user by ID!</span>
<span class="kw">match</span> <span class="ident">dao</span>.<span class="ident">get_user_by_id</span>(<span class="number">123</span>) {
    <span class="prelude-val">Some</span>(<span class="ident">u</span>) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Found a user!&quot;</span>),
    <span class="prelude-val">None</span> <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;No user!&quot;</span>)
};</pre></div>
<h3 id="quiet-metric-sending-and-error-handling" class="section-header"><a href="#quiet-metric-sending-and-error-handling">Quiet Metric Sending and Error Handling</a></h3>
<p>When sending metrics sometimes you don't really care about the <code>Result</code> of
trying to send it or maybe you just don't want to deal with it inline with
the rest of your code. In order to handle this, Cadence allows you to set a
default error handler. This handler is invoked when there are errors sending
metrics so that the calling code doesn't have to deal with them.</p>
<p>An example of configuring an error handler and an example of when it might
be invoked is given below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">cadence</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">MetricError</span>, <span class="ident">StatsdClient</span>, <span class="ident">NopMetricSink</span>};

<span class="kw">fn</span> <span class="ident">my_error_handler</span>(<span class="ident">err</span>: <span class="ident">MetricError</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Metric error! {}&quot;</span>, <span class="ident">err</span>);
}

<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient</span>::<span class="ident">builder</span>(<span class="string">&quot;prefix&quot;</span>, <span class="ident">NopMetricSink</span>)
    .<span class="ident">with_error_handler</span>(<span class="ident">my_error_handler</span>)
    .<span class="ident">build</span>();

<span class="comment">// When sending metrics via the `MetricBuilder` used for assembling tags,</span>
<span class="comment">// callers may opt into sending metrics quietly via the `.send()` method</span>
<span class="comment">// as opposed to the `.try_send()` method</span>
<span class="ident">client</span>.<span class="ident">count_with_tags</span>(<span class="string">&quot;some.counter&quot;</span>, <span class="number">42</span>)
    .<span class="ident">with_tag</span>(<span class="string">&quot;region&quot;</span>, <span class="string">&quot;us-east-2&quot;</span>)
    .<span class="ident">send</span>();</pre></div>
<h3 id="custom-metric-sinks" class="section-header"><a href="#custom-metric-sinks">Custom Metric Sinks</a></h3>
<p>The Cadence <code>StatsdClient</code> uses implementations of the <code>MetricSink</code>
trait to send metrics to a metric server. Most users of the Cadence
library probably want to use the <code>QueuingMetricSink</code> wrapping an instance
of the <code>BufferedMetricSink</code>.</p>
<p>However, maybe you want to do something not covered by an existing sink.
An example of creating a custom sink is below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">MetricSink</span>, <span class="ident">DEFAULT_PORT</span>};

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">MyMetricSink</span>;


<span class="kw">impl</span> <span class="ident">MetricSink</span> <span class="kw">for</span> <span class="ident">MyMetricSink</span> {
    <span class="kw">fn</span> <span class="ident">emit</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">metric</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
        <span class="comment">// Your custom metric sink implementation goes here!</span>
        <span class="prelude-val">Ok</span>(<span class="number">0</span>)
    }
}


<span class="kw">let</span> <span class="ident">sink</span> <span class="op">=</span> <span class="ident">MyMetricSink</span>;
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient</span>::<span class="ident">from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">sink</span>);

<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;my.counter.thing&quot;</span>, <span class="number">42</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;my.method.time&quot;</span>, <span class="number">25</span>);
<span class="ident">client</span>.<span class="ident">incr</span>(<span class="string">&quot;some.other.counter&quot;</span>);</pre></div>
<h3 id="custom-udp-socket" class="section-header"><a href="#custom-udp-socket">Custom UDP Socket</a></h3>
<p>Most users of the Cadence <code>StatsdClient</code> will be using it to send metrics
over a UDP socket. If you need to customize the socket, for example you
want to use the socket in blocking mode but set a write timeout, you can
do that as demonstrated below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">net</span>::<span class="ident">UdpSocket</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">UdpMetricSink</span>, <span class="ident">DEFAULT_PORT</span>};

<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UdpSocket</span>::<span class="ident">bind</span>(<span class="string">&quot;0.0.0.0:0&quot;</span>).<span class="ident">unwrap</span>();
<span class="ident">socket</span>.<span class="ident">set_write_timeout</span>(<span class="prelude-val">Some</span>(<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">1</span>))).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">host</span> <span class="op">=</span> (<span class="string">&quot;metrics.example.com&quot;</span>, <span class="ident">DEFAULT_PORT</span>);
<span class="kw">let</span> <span class="ident">sink</span> <span class="op">=</span> <span class="ident">UdpMetricSink</span>::<span class="ident">from</span>(<span class="ident">host</span>, <span class="ident">socket</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient</span>::<span class="ident">from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">sink</span>);

<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;my.counter.thing&quot;</span>, <span class="number">29</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;my.service.call&quot;</span>, <span class="number">214</span>);
<span class="ident">client</span>.<span class="ident">incr</span>(<span class="string">&quot;some.event&quot;</span>);
<span class="ident">client</span>.<span class="ident">set</span>(<span class="string">&quot;users.uniques&quot;</span>, <span class="number">42</span>);</pre></div>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="ext/index.html" title='cadence::ext mod'>ext</a></td><td class='docblock-short'><p>Extension points for the Cadence library</p>
</td></tr><tr class='module-item'><td><a class="mod" href="prelude/index.html" title='cadence::prelude mod'>prelude</a></td><td class='docblock-short'><p>Export commonly used parts of Cadence for easy glob imports</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.BufferedUdpMetricSink.html" title='cadence::BufferedUdpMetricSink struct'>BufferedUdpMetricSink</a></td><td class='docblock-short'><p>Implementation of a <code>MetricSink</code> that buffers metrics before
sending them to a UDP socket.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Counter.html" title='cadence::Counter struct'>Counter</a></td><td class='docblock-short'><p>Counters are simple values incremented or decremented by a client.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Gauge.html" title='cadence::Gauge struct'>Gauge</a></td><td class='docblock-short'><p>Gauges are an instantaneous value determined by the client.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Histogram.html" title='cadence::Histogram struct'>Histogram</a></td><td class='docblock-short'><p>Histograms are values whose distribution is calculated by the server.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Meter.html" title='cadence::Meter struct'>Meter</a></td><td class='docblock-short'><p>Meters measure the rate at which events occur as determined by the server.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.MetricBuilder.html" title='cadence::MetricBuilder struct'>MetricBuilder</a></td><td class='docblock-short'><p>Builder for adding tags to in-progress metrics.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.MetricError.html" title='cadence::MetricError struct'>MetricError</a></td><td class='docblock-short'><p>Error generated by this library potentially wrapping another
type of error (exposed via the <code>Error</code> trait).</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.NopMetricSink.html" title='cadence::NopMetricSink struct'>NopMetricSink</a></td><td class='docblock-short'><p>Implementation of a <code>MetricSink</code> that discards all metrics.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.QueuingMetricSink.html" title='cadence::QueuingMetricSink struct'>QueuingMetricSink</a></td><td class='docblock-short'><p>Implementation of a <code>MetricSink</code> that wraps another implementation
and uses it to emit metrics asynchronously, in another thread.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Set.html" title='cadence::Set struct'>Set</a></td><td class='docblock-short'><p>Sets count the number of unique elements in a group.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.StatsdClient.html" title='cadence::StatsdClient struct'>StatsdClient</a></td><td class='docblock-short'><p>Client for Statsd that implements various traits to record metrics.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.StatsdClientBuilder.html" title='cadence::StatsdClientBuilder struct'>StatsdClientBuilder</a></td><td class='docblock-short'><p>Builder for creating and customizing <code>StatsdClient</code> instances.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Timer.html" title='cadence::Timer struct'>Timer</a></td><td class='docblock-short'><p>Timers are a positive number of milliseconds between a start and end point.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.UdpMetricSink.html" title='cadence::UdpMetricSink struct'>UdpMetricSink</a></td><td class='docblock-short'><p>Implementation of a <code>MetricSink</code> that emits metrics over UDP.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.ErrorKind.html" title='cadence::ErrorKind enum'>ErrorKind</a></td><td class='docblock-short'><p>Potential categories an error from this library falls into.</p>
</td></tr></table><h2 id='constants' class='section-header'><a href="#constants">Constants</a></h2>
<table><tr class='module-item'><td><a class="constant" href="constant.DEFAULT_PORT.html" title='cadence::DEFAULT_PORT constant'>DEFAULT_PORT</a></td><td class='docblock-short'></td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.Counted.html" title='cadence::Counted trait'>Counted</a></td><td class='docblock-short'><p>Trait for incrementing and decrementing counters.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Gauged.html" title='cadence::Gauged trait'>Gauged</a></td><td class='docblock-short'><p>Trait for recording gauge values.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Histogrammed.html" title='cadence::Histogrammed trait'>Histogrammed</a></td><td class='docblock-short'><p>Trait for recording histogram values.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Metered.html" title='cadence::Metered trait'>Metered</a></td><td class='docblock-short'><p>Trait for recording meter values.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Metric.html" title='cadence::Metric trait'>Metric</a></td><td class='docblock-short'><p>Trait for metrics to expose Statsd metric string slice representation.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.MetricClient.html" title='cadence::MetricClient trait'>MetricClient</a></td><td class='docblock-short'><p>Trait that encompasses all other traits for sending metrics.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.MetricSink.html" title='cadence::MetricSink trait'>MetricSink</a></td><td class='docblock-short'><p>Trait for various backends that send Statsd metrics somewhere.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Setted.html" title='cadence::Setted trait'>Setted</a></td><td class='docblock-short'><p>Trait for recording set values.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Timed.html" title='cadence::Timed trait'>Timed</a></td><td class='docblock-short'><p>Trait for recording timings in milliseconds.</p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.MetricResult.html" title='cadence::MetricResult type'>MetricResult</a></td><td class='docblock-short'></td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "cadence";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>